<script>
  // call方法。
  // 用法 fn.call(obj, 1, 3);

  // Function.prototype.call2 = function(obj) {
  //   var context = obj ? new Object(obj) : window;
  //   context.fn = this;

  //   const args = [];
  //   for(let i = 1; i < arguments.length; i++) {
  //     args.push('arguments[' + i + ']');
  //   }
  //   console.log(args);
  //   const result = eval('context.fn(' + args + ')');
  //   delete context.fn;
  //   return result;
  // }

  // const obj = {
  //   name: 11
  // }
  // const a = function(age) {
  //   console.log(this.name);
  //   console.log(age);
  // }

  // a.call2(obj, 1);

  // apply 方法
  // 用法： fn.apply(obj, [1, 3, 5])

  // Function.prototype.apply2 = function(obj) {
  //   const context = [].shift.call(obj) || window;
  //   context.fn = this;


  //   const result = eval('context.fn(' + arguments + ')');
  //   delete context.fn;
  //   return result;
  // }
  // const obj1 = {
  //   name: 12
  // }
  // const a1 = function(age, work) {
  //   console.log(this.name);
  //   console.log(age);
  //   console.log(work);
  // }
  // a1.apply(obj1, [1, 'dagong']);
  
  // bind 方法
  // 用法： const fn1 = fn.bind(obj, 2)

  Function.prototype.bind2 = function(obj) {
    const context = obj || window;
    const self = this; // fn;
    const args = Array.prototype.slice.call(arguments, 1); // arguments

    function f() {};

    function fBound() {
      const newArgs = Array.prototype.slice.call(arguments); // bind之后的函数的传参;
      console.log(Object.create(this)); 

      return self.apply(this instanceof fBound ? this : context, args.concat(newArgs));
    }

    f.prototype = this.prototype; // 指向fn的prototype
    fBound.prototype = new f(); // fBound 指向f的prototype, == 指向 fn
    return fBound;
  }

  // case1
  const obj = {
    name: 'fang'
  }

  const fn = function(age) {
    console.log(this.name);
    console.log(age);
  }

  const fn1 = fn.bind2(obj, 1);
  const a = new fn1();
  console.log(a);
</script>

